---
description: 가상 면접 사례로 배우는 대규모 시스템 설계 기초 (12장. 채팅 시스템 설계)
---

# 채팅 시스템 설계

## 질문

| 질문                | 답변                                      |
| ----------------- | --------------------------------------- |
| 1:1 채팅인지, 그룹 채팅인지 | 둘 다 지원                                  |
|  모바일 or 웹앱        | 둘 다                                     |
| 트래픽 규모            | DAU : 5000만                             |
| 그룹 채팅의 인원         | 최대 100명                                 |
| 중요 기능             | 1:1 채팅, 그룹 채팅, 사용 접속 상태 표시, 텍스트 메시지만 지원 |
| 메시지 길이 제한         | 100,000 자                               |
| 종단 간 암호화          | 추후 고려                                   |
| 채팅 이력 저장          | 영원히                                     |



## 고려 기술 목록

### 폴링 (Polling)

* 새 메시지가 있는지 물어보는 형식
* 자주 물어볼수록 비용 증가 → 비효율적

### 롱 폴링 (Long-Polling)

* 새 메시지를 받을 때까지 대기하거나, Timeout 처리
* 새 메시지를 받으면 바로 연결이 종료되므로, 폴링과 동일한 상황이 나올 수 있음 → 여전히 비효율적
* 클라이언트가 연결을 종료했는지 아닌지를 서버가 확인할 수 없음 (response 발송 시 에러 확률 있음)

### 웹 소켓 (Web socket)

* 맺어진 연결은 영구적이며, 양방향 메시지 전달 가능
* 서버의 연결 관리가 효율적으로 되어야 함

<figure><img src="../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

## 설계

### 전체 구성

<div align="center">

<figure><img src="../../.gitbook/assets/image (49).png" alt="" width="375"><figcaption></figcaption></figure>

</div>

* 채팅을 제외한 다른 서비스는 무상태 서비스로 구현 (로그인, 인증 등)
* 채팅 서버와 사용자 상태(접속 상태) 서버, Push 알림 서버 구성 필요

### DB

* 일반적인 서비스는 RDB를 사용해도 무방
* 채팅 이력 등의 채팅 서비스와 직접적인 연관이 있는 DB는 주로 NoSQL DB의 key-value 형태의 DB를 주로 사용한다.

<details>

<summary>채팅 서비스의 특징</summary>

* 채팅 이력 데이터가 매우 많음 (ex. 페이스북, whats 는 매일 600억 개의 메시지 처리)
* 이 중, 주로 사용되는 메시지는 최근 메시지 → 오래된 데이터는 자주 보진 않음
* 하지만 오래된 메시지에 대한 검색, mention 확인, 메시지 점프 등의 무작위 데이터 접근도 필요
* 1:1 채팅은 읽기/쓰기 비율이 거의 1:1 비율로 구성됨

</details>

<details>

<summary>key-value 저장소의 채택 이유</summary>

* 수평적 규모 확장 용이
* 데이터 접근 지연 시간 낮음
* 롱테일 데이터 처리 유리
* 검증된 DB (ex. 페이스북 메신저 \[Hbase], 디스코드\[Cassandra] 등이 이미 사용중)

</details>

<details>

<summary>cf. 롱테일이란?</summary>

### 관계형 데이터베이스는 데이터 가운데 롱테일(long tail) 에 해당하는 부분을 잘 처리하지 못하는 경향이 있다고 해. 여기서, 롱테일이 무슨 뜻이야?



→ 롱테일은 데이터에서 빈도수가 낮은 데이터를 의미합니다. 예를 들어, 온라인 쇼핑몰에서 판매되는 제품의 경우, 상위 몇 개의 제품만이 많은 판매량을 차지하고 나머지 제품들은 상대적으로 적은 판매량을 기록합니다. 이러한 데이터 분포를 롱테일 분포라고 합니다.

관계형 데이터베이스는 테이블을 기반으로 데이터를 저장하고 조작하는 데이터베이스입니다. 테이블은 행과 열로 구성되며, 각 행은 하나의 데이터 레코드를 나타내고 각 열은 레코드의 특성을 나타냅니다. 관계형 데이터베이스는 정규화된 데이터를 저장하고 조작하는 데 탁월하지만 롱테일 데이터를 저장하고 조작하는 데는 그다지 효율적이지 않습니다.

그 이유는 관계형 데이터베이스는 데이터의 관계를 기반으로 데이터를 저장하기 때문입니다. 즉, 데이터의 각 레코드에는 다른 레코드와의 관계를 나타내는 키가 있어야 합니다. 이러한 키는 데이터베이스 서버에서 데이터를 빠르게 찾고 조작하는 데 사용됩니다.

롱테일 데이터의 경우, 데이터의 관계가 복잡해지고 키를 생성하기 어려워집니다. 또한 롱테일 데이터는 상대적으로 적은 양의 데이터이기 때문에 데이터베이스 서버에서 데이터를 빠르게 찾고 조작하는 데 어려움이 있습니다.

이러한 이유로 관계형 데이터베이스는 롱테일 데이터를 저장하고 조작하는 데 그다지 효율적이지 않습니다. 롱테일 데이터를 저장하고 조작하는 데는 NoSQL 데이터베이스와 같은 다른 유형의 데이터베이스를 사용하는 것이 좋습니다.

</details>

### DB 모델링

* 1:1 채팅의 경우, message\_id 의 기본키
* 그룹 채팅의 경우, channel\_id + message\_id 의 기본키
* 기본키의 경우 아래와 같은 기준을 만족해야 함
  1. 고유한 message\_id
  2. 정렬 가능한 id + 시간 순서와 일치\
     → NoSQL의 경우, 주로 auto\_increment 를 지원하지 않으므로 별도의 id 생성 로직 필요\
     → 1:1 또는 그룹 채팅 내에서만 id 순서가 보장되면 되므로, 좀 더 지역적으로 구성해도 괜찮음

### 채팅 서버 추천 \[서비스 탐색 기능]

* 클라이언트에게 적합한 채팅 서버를 추천할 수 있어야 함\
  → 클라이언트의 위치 + 각 채팅 서버의 남은 용량 등을 고려하여 추천
* 주로 주키퍼를 사용하여 구현됨

### 메시지 흐름 처리

#### 1:1 채팅

<div align="left">

<figure><img src="../../.gitbook/assets/image (76).png" alt="" width="563"><figcaption></figcaption></figure>

</div>

1. Client 1 이 메시지 전송
2. message\_id 획득 후 Message Queue 로 push
3. message 정보가 key-value 저장소에 저장
4. Client 2 가 접속중이지 않으면 Push Message 전달
5. Client 2 가 접속중이면 접속 중인 채팅 서버에 메시지 전달 (웹 소켓 이용)

cf. 사용자가 여러 Client (단말)을 사용중인 경우

→ 각 단말마다 cur\_max\_message\_id(마지막 수신 메시지 id) 를 가지고 확인하여 처리



#### 그룹 채팅

<div align="left">

<figure><img src="../../.gitbook/assets/image (40).png" alt="" width="563"><figcaption></figcaption></figure>

</div>

* 각 사용자마다 자신의 메시지 큐를 가짐으로서 새 메시지를 확인하기 용이함
* 많은 사용자를 지원해야 한다면, 같은 message 를 여러 큐에 복사하는 것이 바람직하지 않을 수 있음
* WeChat 이 해당 구조를 사용 - 500명의 그룹 채팅 인원 제한



### 접속 상태 표시

* ex. 접속한 경우 닉네임 옆에 초록불이 들어오는 기능
* 접속 상태 서버를 두어 관리
* 단순하게, 웹 소켓으로 통신하며 Client 의 마지막 active 시간을 관리하는 서버 & key-value 저장소로 관리 가능
* API 서버에서 로그인, 로그아웃 처리 시에 key-value 값을 update 처리
* 짧은 시간 끊김을 처리하기 위해 heartbeat 처리 필요
  * ex. 5초마다 서버로 heartbeat 요청 + 서버는 30초 이상 heartbeat 요청이 오지 않는다면 offline 으로 상태 전환



### 상태 정보 전송

<div align="left">

<figure><img src="../../.gitbook/assets/image (21).png" alt="" width="563"><figcaption></figcaption></figure>

</div>

* 기본적으로 발행-구독 모델을 사용
* 웹 소켓을 사용
* 각 친구 관계마다 접속 정보를 확인 가능
* 기본적으로 그룹 내 사용자가 적은 경우에만 사용 가능 (WeChat의 경우 500명)
  * 사용자가 많은 경우, 사용자가 접속했을 경우에만 메시지를 전달하도록 구성\
    또는, 수동으로 갱신하는 방법도 가능
